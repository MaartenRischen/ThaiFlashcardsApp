<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Thai Flashcard Generation Logic - Implementation Details</title>
    <style>
        body {
            font-family: system-ui, -apple-system, sans-serif;
            line-height: 1.6;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            color: #333;
        }
        .section {
            margin-bottom: 40px;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 8px;
        }
        .implementation-note {
            background-color: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 10px;
            margin: 10px 0;
        }
        .code {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 4px;
            overflow-x: auto;
            font-family: monospace;
            white-space: pre;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f8f9fa;
        }
        .warning {
            color: #856404;
            background-color: #fff3cd;
            border: 1px solid #ffeeba;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <h1>Thai Flashcard Generation Logic - Implementation Details</h1>

    <div class="section">
        <h2>1. Model Selection & Fallback System</h2>
        <div class="implementation-note">
            ⚠️ Note: This section reflects the actual implementation with dynamic batch sizing and sophisticated retry mechanisms.
        </div>
        
        <h3>Model Priority Chain</h3>
        <div class="code">
const TEXT_MODELS = [
    'google/gemini-2.5-flash-preview',    // Primary choice
    'google/gemini-2.5-pro-preview-03-25', // First fallback
    'openai/gpt-4',                       // Second fallback
    'openai/gpt-3.5-turbo',               // Third fallback
    'anthropic/claude-3-opus',            // Fourth fallback
    'mistralai/mixtral-8x7b'             // Final fallback
];
        </div>

        <h3>Dynamic Batch Processing</h3>
        <div class="code">
// Dynamic batch size based on model capabilities
function getBatchSize(model: string): number {
    switch (model) {
        case 'google/gemini-2.5-flash-preview': return 8;
        case 'openai/gpt-4': return 4;
        default: return 3;
    }
}

// Exponential backoff retry strategy
const MAX_RETRIES = 3;
const getBackoffDelay = (retry: number) => Math.pow(2, retry) * 1000;
        </div>

        <h3>Error Handling System</h3>
    <table>
            <tr>
                <th>Error Type</th>
                <th>Handling Strategy</th>
                <th>Retry Logic</th>
            </tr>
            <tr>
                <td>API Errors</td>
                <td>Model fallback + exponential backoff</td>
                <td>Up to 3 retries per model</td>
            </tr>
            <tr>
                <td>Network Errors</td>
                <td>Immediate retry with backoff</td>
                <td>Up to 3 retries</td>
            </tr>
            <tr>
                <td>Validation Errors</td>
                <td>Partial result acceptance + continue</td>
                <td>No retry (non-retryable)</td>
            </tr>
            <tr>
                <td>Parse Errors</td>
                <td>Model fallback</td>
                <td>Switch model, then retry</td>
            </tr>
        </table>
    </div>

    <div class="section">
        <h2>2. Temperature Control System</h2>
        <div class="implementation-note">
            ⚠️ Note: Temperature control is tightly integrated with tone levels and affects both generation and validation.
        </div>

        <h3>Temperature Mapping</h3>
        <div class="code">
// Non-linear temperature progression based on tone level
function getTemperatureFromToneLevel(toneLevel: number | undefined): number {
    // Default to level 5 (balanced) if undefined
    const level = toneLevel ?? 5;
    
    // Clamp between 1 and 10
    const clampedLevel = Math.max(1, Math.min(10, level));
    
    const temperatureMap: Record<number, number> = {
        1: 0.1,   // Dead serious
        2: 0.3,   // Barely a smile
        3: 0.4,   // Slight humor
        4: 0.5,   // Last practical level
        5: 0.7,   // Starting to get weird
        6: 0.8,   // Definitely weird
        7: 0.9,   // Very weird
        8: 0.95,  // Reality-bending
        9: 1.5,   // Reality-breaking
        10: 2.0   // Maximum possible chaos
    };
    
    return temperatureMap[clampedLevel];
}
        </div>

        <h3>Temperature Behavior by Level</h3>
        <table>
            <tr>
                <th>Level</th>
                <th>Temperature</th>
                <th>Generation Behavior</th>
                <th>Validation Rules</th>
            </tr>
            <tr><td>1</td><td>0.1</td><td>Dead serious, purely practical, textbook-style</td><td>Strict practicality and grammar</td></tr>
            <tr><td>2</td><td>0.3</td><td>Serious, very subtle levity allowed</td><td>Strict practicality and grammar</td></tr>
            <tr><td>3</td><td>0.4</td><td>Practical, emerging fun/humor</td><td>Practicality, grammar</td></tr>
            <tr><td>4</td><td>0.5</td><td>Playful practicality, noticeable humor</td><td>Practicality, grammar</td></tr>
            <tr><td>5</td><td>0.7</td><td>Balanced absurdity, mix of practical and illogical</td><td>Grammar, relaxed semantic validation</td></tr>
            <tr><td>6</td><td>0.8</td><td>Leaning weird, bizarre contexts</td><td>Grammar, relaxed semantic validation</td></tr>
            <tr><td>7</td><td>0.9</td><td>Very weird, surreal humor, strange concepts</td><td>Grammar, relaxed semantic validation</td></tr>
            <tr><td>8</td><td>0.95</td><td>Reality-bending, semantically strange</td><td>Grammar only</td></tr>
            <tr><td>9</td><td>1.5</td><td>Reality-breaking, chaotic, nonsensical</td><td>Grammar only</td></tr>
            <tr><td>10</td><td>2.0</td><td>Maximum chaos, pure surrealism</td><td>Grammar only</td></tr>
    </table>
    </div>

    <div class="section">
        <h2>3. Batch Processing System</h2>
        <div class="implementation-note">
            ⚠️ Note: Batch processing includes sophisticated progress tracking and error aggregation.
        </div>

        <h3>Batch Generation Flow</h3>
        <div class="code">
interface BatchProgress {
    completed: number;
    total: number;
    latestPhrases?: Phrase[];
}

// Main generation loop with progress tracking
for (let i = 0; i < batchesNeeded; i++) {
    // Update progress immediately
    onProgressUpdate?.({ 
        completed: allPhrases.length, 
        total: totalCount,
        latestPhrases: allPhrases.slice(-3)
    });
    
    // Calculate remaining phrases needed
    const remaining = totalCount - allPhrases.length;
    const countForBatch = Math.min(remaining, batchSize);
    
    // Generate batch with retries
    let retries = 0;
    while (retries < MAX_RETRIES) {
        try {
            const result = await generateOpenRouterBatch(
                prompt, 
                TEXT_MODELS,
                i,
                preferences.toneLevel
            );
            
            if (result.phrases.length > 0) break;
            
            retries++;
            await new Promise(resolve => 
                setTimeout(resolve, getBackoffDelay(retries))
            );
        } catch (error) {
            aggregatedErrors.push(createBatchError(error, i));
            retries++;
        }
    }
}
        </div>

        <h3>Error Aggregation</h3>
        <div class="code">
interface BatchError {
    type: 'PARSE' | 'VALIDATION' | 'API' | 'NETWORK' | 'UNKNOWN';
    message: string;
    details?: unknown;
    batchIndex: number;
}

interface ErrorSummary {
    errorTypes: string[];
    totalErrors: number;
    userMessage: string;
}
        </div>
    </div>

    <div class="section">
        <h2>4. Storage Pipeline</h2>
        <div class="implementation-note">
            ⚠️ Note: Storage includes compatibility mapping and rollback mechanisms.
        </div>

        <h3>Storage Flow</h3>
        <div class="code">
// Metadata mapping for database compatibility
function mapStorageToDatabase(storageSet: SetMetaData): DatabaseSet {
    const { toneLevel, ...rest } = storageSet;
    return {
        ...rest,
        seriousnessLevel: toneLevel, // Backward compatibility
    };
}

function mapDatabaseToStorage(dbSet: DatabaseSet): SetMetaData {
    return {
        ...dbSet,
        toneLevel: dbSet.seriousnessLevel,
    };
}

// Storage sequence with rollback
async function storeGeneratedSet(userId: string, set: CustomSet) {
    const session = await startTransaction();
    try {
        // 1. Save metadata
        const meta = await saveMetadata(session, userId, set);
        
        // 2. Save phrases
        const phrases = await savePhrases(session, meta.id, set.phrases);
        
        // 3. Save progress data
        const progress = await saveProgress(session, meta.id);
        
        await session.commitTransaction();
        return { meta, phrases, progress };
    } catch (error) {
        await session.abortTransaction();
        throw error;
    }
}
        </div>
    </div>

    <div class="section">
        <h2>5. Proficiency Level Implementation Rules</h2>
        <div class="implementation-note">
            ⚠️ Note: These rules are strictly enforced during generation to tailor vocabulary, grammar, and complexity.
        </div>
        <table>
            <thead>
                <tr>
                    <th>Proficiency Level</th>
                    <th>Description & Constraints</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Complete Beginner</td>
                    <td>Use ONLY single words or two-word combinations (noun+verb or noun+adjective). Focus on the absolute most basic, high-frequency vocabulary. Examples must be single-word or two-word statements only. NO questions, NO dialogues, NO complex structures.</td>
                </tr>
                <tr>
                    <td>Basic Understanding</td>
                    <td>Use short, practical phrases (2-4 words). Focus on basic S-V-O structures and common expressions for everyday needs. Simple questions are okay. Avoid dialogues. Examples should be basic descriptive statements about daily life.</td>
                </tr>
                <tr>
                    <td>Intermediate</td>
                    <td>Use medium-length descriptive sentences (4-7 words). Include basic compound structures and typical vocabulary for common situations. Simple questions and compound sentences are okay. Avoid dialogues. Examples should describe everyday situations.</td>
                </tr>
                <tr>
                    <td>Advanced</td>
                    <td>Use moderately complex sentences (7-12 words). Include varied grammar structures and more nuanced vocabulary. Complex questions and compound-complex sentences are okay. Avoid dialogues. Examples should demonstrate natural Thai expression.</td>
                </tr>
                <tr>
                    <td>Native/Fluent</td>
                    <td>Use natural, idiomatic Thai (any appropriate length). Include slang, cultural references, and educated native speech patterns. Complex questions and varied sentence structures are encouraged. Avoid dialogues. Examples should sound like authentic Thai.</td>
                </tr>
                <tr>
                    <td>God Mode</td>
                    <td>Use sophisticated, elaborate Thai (extended length). Include rare vocabulary, advanced grammar patterns, and literary/academic language. Complex questions and varied structures are encouraged. Avoid dialogues. Examples should demonstrate mastery of formal and literary Thai.</td>
                </tr>
            </tbody>
        </table>
    </div>

    <div class="section">
        <h2>6. Prompt Structure (Simplified)</h2>
        <div class="implementation-note">
            ⚠️ Note: This shows the main sections of the prompt sent to the LLM. The actual prompt includes dynamically injected preferences and detailed rule sets for Tone and Proficiency.
        </div>
        <div class="code">
You are an expert AI assistant specialized in creating language learning flashcards...

**CRITICAL TASK REQUIREMENTS:**
- Adhere STRICTLY to Proficiency Level: \${level}
- Adhere STRICTLY to Tone Level: \${toneLevel}
- ...

**User Preferences:**
- Proficiency Level: \${level}
- Tone Level: \${toneLevel}
- Situations for Use: \${topicsToDiscuss || 'General conversation'}
- Specific Focus: \${specificTopics || 'None'}

**DETAILED INSTRUCTIONS:**

1.  **Set Title:** (Rules for generating title based on user topics)

2.  **Proficiency Level Implementation (\${level}):** 
    *   \${selectedLevelDescription} // Inject specific rules here

3.  **TONE Implementation (\${toneLevel}):** 
    *   Tone Style Guide (Detailed rules for levels 1-10)
    *   Content Guidelines by Component (Phrases, Examples, Mnemonics)
    *   Example Outputs by Level
    *   Key Rules (e.g., maintain grammar, level constraints)

4.  **Topic/Situation Control:** (Instructions on focusing content)

5.  **Avoid Duplicates:** (Instructions to avoid generating existing phrases: \${existingPhrases})

**Output Format:**
Generate a JSON object containing "cleverTitle" and "phrases".
- "cleverTitle": (Rules)
- "phrases": An array containing exactly \${count} unique flashcard objects...
  \`\`\`typescript
  interface Phrase { ... } // Full interface definition
  interface ExampleSentence { ... } // Full interface definition
  \`\`\`
  CRITICAL: Each phrase MUST include at least 2 example sentences...
  Ensure the entire response is ONLY the JSON object...
        </div>
    </div>

    <div class="section">
        <h2>7. Generation Parameters</h2>
        <div class="implementation-note">
            ⚠️ Note: Parameters are dynamically adjusted based on multiple factors.
        </div>

        <h3>Dynamic Parameters</h3>
        <table>
            <tr>
                <th>Parameter</th>
                <th>Range</th>
                <th>Adjustment Factors</th>
            </tr>
            <tr>
                <td>Batch Size</td>
                <td>3-8</td>
                <td>Model capabilities, memory constraints</td>
            </tr>
            <tr>
                <td>Temperature</td>
                <td>0.1-2.0</td>
                <td>Tone level, model characteristics</td>
            </tr>
            <tr>
                <td>Retry Count</td>
                <td>0-3</td>
                <td>Error type, model availability</td>
            </tr>
            <tr>
                <td>Backoff Delay</td>
                <td>1s-8s</td>
                <td>Retry attempt number</td>
            </tr>
    </table>
    </div>

    <div class="section">
        <h2>8. Validation System</h2>
        <div class="implementation-note">
            ⚠️ Note: Validation checks structure, content, and semantics (based on tone).
        </div>

        <h3>Validation Steps & Tone Logic</h3>
        <ol>
            <li><strong>Structure & Content Validation:</strong> Checks if required fields exist (<code>english</code>, <code>thai</code>, etc.), data types are correct, and minimum example count (>=2) is met. Checks basic mnemonic quality. Performed on all tones.</li>
            <li><strong>Duplicate Check:</strong> Normalizes and compares the <code>english</code> phrase against existing phrases in the batch to prevent duplicates. Performed on all tones.</li>
            <li>
                <strong>Semantic Validation (Tone-Dependent):</strong> Checks if the generated content makes logical sense.
                <ul>
                    <li><strong>Tones 1-6 (Strict):</strong> Semantic checks are performed. Illogical or nonsensical phrases/examples should be rejected. (<em>Code currently has placeholder - assumes pass</em>).</li>
                    <li><strong>Tones 7-8 (Partial):</strong> Semantic checks are currently <strong>skipped</strong> (treated as 'none').</li>
                    <li><strong>Tones 9-10 (None):</strong> Semantic checks are skipped, allowing absurd or nonsensical (but grammatically correct) content.</li>
                </ul>
            </li>
        </ol>

        <div class="warning">
            <strong>Current Implementation Status:</strong> The codebase includes the *structure* for tone-dependent semantic validation, but the actual semantic check logic for Tones 1-6 is currently a placeholder and always passes. Further implementation is needed for full semantic validation.
        </div>

        <div class="code">
// Example of how rules *might* be represented (Conceptual)
 interface ValidationRules {
     // Structure validation
     requiredFields: string[];
     typeChecks: Record<string, string>;
     
     // Content validation
     minExamples: number;
     // maxPhraseLength: Record<string, number>; // Not currently implemented based on tone
     // requireMnemonic: boolean; // Quality checked instead
     
     // Tone-specific rules
     // allowedContexts: string[]; // Handled by semanticChecks
     semanticChecks: 'strict' | 'partial' | 'none'; // Determines if logical sense is checked
     grammarChecks: boolean; // Should always be true
 }
 
 // Conceptual rule sets based on CURRENT IMPLEMENTATION:
 const validationRulesByTone: Record<number, { semanticChecks: 'strict' | 'none' }> = {
     1: { semanticChecks: 'strict' }, // Tones 1-6
     2: { semanticChecks: 'strict' },
     3: { semanticChecks: 'strict' },
     4: { semanticChecks: 'strict' },
     5: { semanticChecks: 'strict' },
     6: { semanticChecks: 'strict' },
     7: { semanticChecks: 'none' },   // Tones 7-10 (incl. 'partial')
     8: { semanticChecks: 'none' },
     9: { semanticChecks: 'none' },
     10: { semanticChecks: 'none' }
 };
        </div>
        </div>

    <div class="section">
        <h2>9. Progress Tracking</h2>
        <div class="implementation-note">
            ⚠️ Note: Sophisticated progress tracking with multiple metrics.
        </div>

        <h3>Progress Interface</h3>
        <div class="code">
interface GenerationProgress {
    completed: number;
    total: number;
    latestPhrases?: Phrase[];
    errors?: BatchError[];
    currentModel?: string;
    batchesCompleted: number;
    estimatedTimeRemaining?: number;
}
        </div>
        </div>

    <div class="section">
        <h2>10. Error Handling</h2>
        <div class="implementation-note">
            ⚠️ Note: Comprehensive error handling with aggregation and recovery.
        </div>

        <h3>Error Types</h3>
        <table>
            <tr>
                <th>Type</th>
                <th>Recovery Strategy</th>
                <th>User Impact</th>
            </tr>
            <tr>
                <td>Model Errors</td>
                <td>Fallback to next model</td>
                <td>Minimal - transparent retry</td>
            </tr>
            <tr>
                <td>Validation Errors</td>
                <td>Partial acceptance</td>
                <td>Reduced set size</td>
            </tr>
            <tr>
                <td>Critical Errors</td>
                <td>Fallback content</td>
                <td>Basic set provided</td>
            </tr>
        </table>
        </div>

    <div class="section">
        <h2>11. UI Integration</h2>
        <div class="implementation-note">
            ⚠️ Note: Complete UI system for tone selection and progress tracking.
        </div>

        <h3>Components</h3>
        <ul>
            <li>Tone Selection
                <ul>
                    <li>Slider interface (1-10)</li>
                    <li>Visual previews</li>
                    <li>Example content</li>
                </ul>
            </li>
            <li>Progress Display
                <ul>
                    <li>Completion percentage</li>
                    <li>Latest phrases</li>
                    <li>Error summaries</li>
                </ul>
            </li>
            <li>Error Handling
                <ul>
                    <li>User-friendly messages</li>
                    <li>Retry options</li>
                    <li>Fallback content</li>
                </ul>
            </li>
        </ul>
    </div>
</body>
</html> 